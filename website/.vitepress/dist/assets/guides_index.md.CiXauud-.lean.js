import{_ as t,c as a,ab as r,o}from"./chunks/framework.0Hiw1RrX.js";const p=JSON.parse('{"title":"Introduction","description":"","frontmatter":{},"headers":[],"relativePath":"guides/index.md","filePath":"guides/index.md"}'),i={name:"guides/index.md"};function n(s,e,l,c,d,h){return o(),a("div",null,e[0]||(e[0]=[r('<h1 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h1><h2 id="why-graffle" tabindex="-1">Why Graffle? <a class="header-anchor" href="#why-graffle" aria-label="Permalink to &quot;Why Graffle?&quot;">​</a></h2><p>Graffle is a GraphQL client for JavaScript that works in all major run-times (browsers, Node, Deno, Bun, Cloudflare Workers, ...). It&#39;s goal is to be a fantastic general purpose way to execute <a href="https://todo" target="_blank" rel="noreferrer">GraphQL documents</a> in scripts or backend logic. It may work work well for your frontend logic too but Graffle does not specialize there unlike other tools such as <a href="https://relay.dev" target="_blank" rel="noreferrer">RelayJS</a> and <a href="https://commerce.nearform.com/open-source/urql/docs/" target="_blank" rel="noreferrer">Urql</a>.</p><p>Initially Graffle is an easy way to send GraphQL requests over HTTP or in-memory. Extensions bring additional power like <a href="https://todo" target="_blank" rel="noreferrer">OTEL</a> or <a href="https://todo" target="_blank" rel="noreferrer">file upload</a> support. You work with GraphQL&#39;s native document syntax. This description so far paints Graffle as a more flexible and stable version of its previous version known as <code>graphql-request</code>. However, its value proposition doesn&#39;t end there. You can opt into using its generated client bringing benefits like:</p><ol><li>A TypeScript first interface for creating and sending requests including method names that reflect the schema.</li><li>Type-safe request inputs (selection set, directives, etc.).</li><li>Type-safe request outputs (results) inferred from the input.</li><li>Automatic encoding and decoding of custom scalars.</li><li>Type utilities to create TypeScript types based on types in the GraphQL schema.</li><li>Runtime utilities to create reusable selection sets.</li></ol><p>Take Graffle for a spin, let us know what you think. We hope you have as much fun working with Graffle as we are building it. ❤️</p><h2 id="about-these-docs" tabindex="-1">About These Docs <a class="header-anchor" href="#about-these-docs" aria-label="Permalink to &quot;About These Docs&quot;">​</a></h2><p>Graffle&#39;s website documentation is primarily divided between these guides and <a href="./../examples/">examples</a>. Detailed reference information is largely left to JSDoc and TypeScript types. However, thanks to <a href="https://twoslash.netlify.app" target="_blank" rel="noreferrer">Twoslash</a> that information is also made available within the website docs.</p><p>Guides are built around domains rather than technical locality so for example many aspects of configuration are embedded into each one&#39;s respective area of concern like <a href="./transports/http">HTTP Transport</a> or <a href="./10_overview/output">Output</a>. Throughout, guides reference <a href="./../examples/raw">Examples</a> in context helping you jump between theory and practice. As well, know that all examples are automatically tested in Graffle&#39;s continuous integration so you can be confident in their functionality.</p><div class="note custom-block github-alert"><p class="custom-block-title">Generated Client Icon <span style="font-size:2em;line-height:0;" title="generation required">⩕</span></p><p>This icon is used throughout the guides to denote that the content <strong>only applies to the generated client</strong>.</p></div>',10)]))}const f=t(i,[["render",n]]);export{p as __pageData,f as default};
